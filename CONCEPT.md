# TimeForged: концепция self-hosted трекера времени на Rust

## Обзор идеи

TimeForged — это self-hosted демон и CLI-утилита на Rust для автоматического учёта времени, проведённого в разработке (код, проекты, связанная активность), независимо от конкретного редактора или IDE. В отличие от плагинов уровня VS Code или Zed, TimeForged живёт как отдельный сервис (нативный бинарь или Docker-контейнер) и собирает события из разных источников в единую внутреннюю базу.

## Цели проекта

- Давать честную, агрегированную статистику по времени разработки по всем редакторам, терминалам и машинам (локально + удалённые dev-серверы).
- Оставаться максимально лёгким по ресурсам и подходящим для self-hosting на дешёвом VPS или домашнем сервере (Rust + SQLite/PostgreSQL).
- Не требовать облака третьих сторон: все данные хранятся у пользователя, доступны через CLI/API и, при желании, локальный веб-UI.
- Быть расширяемым: возможность писать простые интеграции (хуки, небольшие клиенты) для новых редакторов, терминальных тулз и CI-систем.

## Негласный ориентир: WakaTime, но self-hosted и под себя

Существующие решения вроде WakaTime и Wakapi показывают удобную модель: плагины редакторов шлют «heartbeats» на центральный backend, который строит метрики и графики. Есть уже несколько self-hosted реализаций (Wakapi на Go, Tempo и rustytime-server на Rust), совместимых с протоколом WakaTime.

TimeForged логично строить как более узко заточенный под личное использование сервис:

- Фокус на личной/малой команде, а не SaaS с многим функционалом.
- Упор на производительность, предсказуемость и простой деплой (один бинарь или одна Docker-служба).
- Возможность поверх стандартных heartbeats добавлять собственные типы событий (контекст задач, ветки git, ноды n8n, мини-игры и т.п.).

## Почему Rust уместен

- Rust даёт низкое потребление памяти и CPU при долгоживущих демонах, что критично для self-hosted сервисов на малых VPS и домашнем железе.
- Экосистема уже содержит примеры time-tracking и дев-инструментов на Rust (Tempo backend, rtw, timetrack), что даёт хорошие архитектурные референсы.
- Возможность собрать полностью статический бинарь и распространять один файл без внешних рантаймов или интерпретаторов.

## Высокоуровневая архитектура

### Компоненты

- **Core-демон `timeforged`**: долгоживущий процесс, принимающий события (heartbeats) по HTTP/gRPC/Unix-сокету и пишущий их в БД.
- **CLI-клиент `tf`**: оболочка для запросов к демону (статистика, отчёты, ручные интервалы, настройки профиля).
- **Лёгкий веб-UI (опционально)**: SPA/SSR поверх REST/GraphQL API для визуализации графиков и фильтров.
- **Интеграции/агенты**: маленькие клиенты для Zed, VS Code, Claude Code, терминала, которые отправляют события в TimeForged (вдохновляясь моделью плагинов WakaTime).

### Поток данных

1. Агент/плагин в редакторе фиксирует файл, проект, язык, временную метку и активность (тайпинг/idle).
2. Отправляет heartbeat в TimeForged: пользователь, проект, путь, язык, длительность/момент.
3. Демон валидирует событие, нормализует (сопоставляет с проектом/тегами) и сохраняет в БД.
4. CLI/UI считывает агрегированные данные и строит отчёты по диапазонам, проектам, контекстам.

## Ключевые фичи MVP

- Приём и хранение базовых heartbeats по протоколу, максимально близкому к WakaTime, чтобы при желании переиспользовать существующие плагины.
- Авторизация по API-ключу, возможность завести несколько пользователей в одной инстанции.
- SQLite по умолчанию, опциональная поддержка PostgreSQL для более тяжёлых сценариев.
- CLI-отчёты: суммарное время за день/неделю/месяц, топ проектов, топ языков, последние сессии.
- Простая конфигурация через `.toml`/`.yaml` + переменные окружения (порт, DSN, storage-путь).

## Возможные направления развития

- Локальный Pomodoro/фокус-режим, связанный с событиями кодинга.
- Интеграции с Git: связывать коммиты и ветки с интервалами времени, строить отчёты «время на фичу/ветку».
- Поддержка нескольких устройств: отправка heartbeats с ноутбука/десктопа/удалённых dev-серверов в одну инстанцию TimeForged.
- Экспорт в форматы (JSON/CSV) для дальнейшей аналитики или загрузки в персональные дэшборды/BI-системы.
- Плагин-мост к существующим WakaTime-совместимым backend'ам (например, проксирование на Wakapi или rustytime-server при необходимости).

## Позиционирование

TimeForged можно позиционировать как:

- **«Личный кузнец времени разработчика»** — минималистичный, быстрый, полностью под контролем пользователя.
- Rust-ориентированный self-hosted трекер, который удобен как для единичного разработчика, так и для маленькой команды.
- Осознанная альтернатива облачным сервисам: без подписок, без передачи данных третьим лицам, с прозрачной архитектурой и простым деплоем (одна Docker-служба или один бинарь).
